import * as fs from "node:fs";
import * as path from "node:path";

// Event names from euler-websocket-sdk (WebcastEventName type)
// Only messages WITH a 'common' property are included
const WEBCAST_EVENT_NAMES = [
  "WebcastRoomUserSeqMessage",
  "WebcastChatMessage",
  "WebcastEmoteChatMessage",
  "WebcastMemberMessage",
  "WebcastGiftMessage",
  "WebcastLinkMicBattle",
  "WebcastLinkMicArmies",
  "WebcastSocialMessage",
  "WebcastLikeMessage",
  "WebcastQuestionNewMessage",
  "WebcastLiveIntroMessage",
  "WebcastHourlyRankMessage",
  "WebcastEnvelopeMessage",
  "WebcastSubNotifyMessage",
  "WebcastBarrageMessage",
  "WebcastRoomMessage",
  "WebcastCaptionMessage",
  "WebcastControlMessage",
  "WebcastGoalUpdateMessage",
  "WebcastImDeleteMessage",
  "WebcastInRoomBannerMessage",
  "WebcastRankUpdateMessage",
  "WebcastPollMessage",
  "WebcastRankTextMessage",
  "WebcastLinkMicBattlePunishFinish",
  "WebcastLinkmicBattleTaskMessage",
  "WebcastLinkMicFanTicketMethod",
  "WebcastLinkMicMethod",
  "WebcastUnauthorizedMemberMessage",
  "WebcastMsgDetectMessage",
  "WebcastOecLiveShoppingMessage",
  "WebcastRoomPinMessage",
  "WebcastLinkMessage",
  "WebcastLinkLayerMessage",
  "RoomVerifyMessage",
] as const;

function generateHookFile(eventName: string): string {
  const hookName = `use${eventName}`;

  return `/**
 * Auto-generated hook for ${eventName}
 * DO NOT EDIT - This file is generated by hook-generator
 */
import { useWebcastEvent, useWebcastEventHistory } from "../useWebcastEvent";
import type { WebcastMessageMap } from "@eulerstream/euler-websocket-sdk";

export type ${eventName}Data = WebcastMessageMap["${eventName}"];

/**
 * Hook to get the latest ${eventName} event.
 */
export function ${hookName}(): ${eventName}Data | null {
  return useWebcastEvent("${eventName}");
}

/**
 * Hook to get a history of ${eventName} events.
 */
export function ${hookName}History(maxHistory = 100): ${eventName}Data[] {
  return useWebcastEventHistory("${eventName}", maxHistory);
}
`;
}

function generateIndexFile(eventNames: readonly string[]): string {
  const exports = eventNames
    .map((name) => {
      const fileName = name.charAt(0).toLowerCase() + name.slice(1);
      return `export * from "./${fileName}";`;
    })
    .join("\n");

  return `/**
 * Auto-generated hooks index
 * DO NOT EDIT - This file is generated by hook-generator
 */
${exports}
`;
}

interface GenerateHooksOptions {
  output: string;
}

export function generateHooksCommand(options: GenerateHooksOptions) {
  const outputDir = path.resolve(process.cwd(), options.output);

  // Create output directory
  fs.mkdirSync(outputDir, { recursive: true });

  console.log(`Generating hooks to ${outputDir}...`);

  // Generate individual hook files
  for (const eventName of WEBCAST_EVENT_NAMES) {
    const fileName = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    const filePath = path.join(outputDir, `${fileName}.ts`);
    const content = generateHookFile(eventName);

    fs.writeFileSync(filePath, content);
    console.log(`  Generated ${fileName}.ts`);
  }

  // Generate index file
  const indexPath = path.join(outputDir, "index.ts");
  const indexContent = generateIndexFile(WEBCAST_EVENT_NAMES);
  fs.writeFileSync(indexPath, indexContent);
  console.log(`  Generated index.ts`);

  console.log(`\nDone! Generated ${WEBCAST_EVENT_NAMES.length} hook files.`);
}
